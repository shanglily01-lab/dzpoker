# 德州扑克发牌算法AI测试系统 - 系统架构设计

## 1. 总体架构概览

### 1.1 架构原则
- **微服务化**: 各功能模块独立部署,松耦合
- **高可用**: 无单点故障,支持故障自动转移
- **可扩展**: 支持水平扩展,弹性伸缩
- **数据驱动**: 以数据流为核心,支持实时处理
- **AI原生**: AI能力深度集成到各个模块

### 1.2 分层架构

```
┌──────────────────────────────────────────────────────────────┐
│                        接入层 (Access Layer)                  │
│  ┌────────────┐  ┌────────────┐  ┌────────────┐              │
│  │ Web Portal │  │ Admin Panel│  │  API SDK   │              │
│  │  (前端)    │  │  (管理后台) │  │  (第三方)  │              │
│  └────────────┘  └────────────┘  └────────────┘              │
└────────────────────────┬─────────────────────────────────────┘
                         │ HTTPS / WSS
┌────────────────────────┴─────────────────────────────────────┐
│                      网关层 (Gateway Layer)                   │
│  ┌──────────────────────────────────────────────────┐        │
│  │           API Gateway (Kong / Nginx)              │        │
│  │  ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐  │        │
│  │  │认证  │ │限流  │ │路由  │ │监控  │ │日志  │  │        │
│  │  └──────┘ └──────┘ └──────┘ └──────┘ └──────┘  │        │
│  └──────────────────────────────────────────────────┘        │
└────────────────────────┬─────────────────────────────────────┘
                         │ gRPC / REST
┌────────────────────────┴─────────────────────────────────────┐
│                    业务服务层 (Service Layer)                 │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 发牌引擎    │  │ 玩家分析    │  │ AI训练      │          │
│  │ Dealing     │  │ Player      │  │ ML Training │          │
│  │ Engine      │  │ Analysis    │  │ Service     │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ 测试服务    │  │ 数据采集    │  │ 报表服务    │          │
│  │ Testing     │  │ Data        │  │ Report      │          │
│  │ Service     │  │ Collection  │  │ Service     │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└────────────────────────┬─────────────────────────────────────┘
                         │
┌────────────────────────┴─────────────────────────────────────┐
│                    数据服务层 (Data Layer)                    │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │ PostgreSQL  │  │  MongoDB    │  │   Redis     │          │
│  │ (主数据库)  │  │ (文档存储)  │  │  (缓存)     │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐          │
│  │  InfluxDB   │  │   Kafka     │  │    MinIO    │          │
│  │ (时序数据)  │  │ (消息队列)  │  │ (对象存储)  │          │
│  └─────────────┘  └─────────────┘  └─────────────┘          │
└──────────────────────────────────────────────────────────────┘
```

---

## 2. 核心模块详细设计

### 2.1 发牌引擎服务 (Dealing Engine Service)

#### 2.1.1 模块架构
```
Dealing Engine Service
├── API Layer (接口层)
│   ├── REST API
│   ├── WebSocket API
│   └── gRPC API
├── Business Logic Layer (业务逻辑层)
│   ├── Standard Dealer (标准发牌器)
│   ├── Smart Dealer (智能发牌器)
│   ├── Probability Controller (概率控制器)
│   └── Fairness Validator (公平性验证器)
├── Algorithm Layer (算法层)
│   ├── RNG Engine (随机数生成)
│   ├── Deck Manager (牌堆管理)
│   ├── Card Shuffler (洗牌算法)
│   └── Distribution Strategy (分配策略)
└── Data Access Layer (数据访问层)
    ├── Game Repository
    ├── Hand Repository
    └── Cache Manager
```

#### 2.1.2 核心类设计

```python
# 发牌引擎核心类
class DealingEngine:
    """发牌引擎主类"""

    def __init__(self, config: EngineConfig):
        self.rng = RandomNumberGenerator()
        self.deck_manager = DeckManager()
        self.strategy = DealingStrategy()
        self.validator = FairnessValidator()

    def deal_hand(self, table: Table, players: List[Player]) -> HandResult:
        """发一手牌"""
        pass

    def deal_flop(self, game: Game) -> List[Card]:
        """发翻牌"""
        pass

    def deal_turn(self, game: Game) -> Card:
        """发转牌"""
        pass

    def deal_river(self, game: Game) -> Card:
        """发河牌"""
        pass


# 智能发牌策略
class SmartDealingStrategy:
    """智能发牌策略"""

    def __init__(self, ai_model: AIModel):
        self.model = ai_model
        self.entertainment_weight = 0.3
        self.fairness_weight = 0.7

    def calculate_distribution(
        self,
        players: List[Player],
        context: GameContext
    ) -> CardDistribution:
        """计算牌的分配策略"""
        # 1. 分析玩家状态
        player_states = self._analyze_players(players)

        # 2. AI预测最优分配
        distribution = self.model.predict(player_states, context)

        # 3. 应用公平性约束
        distribution = self._apply_fairness_constraints(distribution)

        return distribution

    def adjust_probability(
        self,
        player: Player,
        card_strength: float
    ) -> float:
        """调整玩家获得特定强度牌的概率"""
        base_prob = 1.0

        # 根据玩家状态调整
        if player.is_inactive:
            base_prob *= 1.1  # 提升10%

        if player.consecutive_losses > 5:
            base_prob *= 1.15  # 连续输牌补偿

        # 确保调整幅度不超过20%
        return min(base_prob, 1.2)


# 随机数生成器
class RandomNumberGenerator:
    """加密级随机数生成器"""

    def __init__(self, seed: Optional[int] = None):
        self.seed = seed
        self.entropy_pool = EntropyPool()

    def generate(self, min_val: int, max_val: int) -> int:
        """生成随机数"""
        pass

    def shuffle(self, items: List[Any]) -> List[Any]:
        """洗牌算法 (Fisher-Yates)"""
        pass

    def verify_randomness(self, samples: List[int]) -> bool:
        """验证随机性 (统计检验)"""
        pass
```

#### 2.1.3 数据流设计

```
玩家请求 → API Gateway → Dealing Engine
                            ↓
                    1. 获取玩家信息 (Redis)
                            ↓
                    2. AI预测最优分配 (AI Service)
                            ↓
                    3. 生成牌面 (RNG)
                            ↓
                    4. 公平性验证 (Validator)
                            ↓
                    5. 保存牌局数据 (PostgreSQL + MongoDB)
                            ↓
                    6. 推送结果 (WebSocket)
                            ↓
                    7. 异步数据分析 (Kafka → Analytics)
```

---

### 2.2 玩家分析服务 (Player Analysis Service)

#### 2.2.1 模块架构
```
Player Analysis Service
├── Real-time Analysis (实时分析)
│   ├── Behavior Tracker (行为追踪)
│   ├── Action Analyzer (动作分析)
│   └── Emotion Detector (情绪检测)
├── Player Profiling (玩家画像)
│   ├── Type Classifier (类型分类)
│   ├── Skill Evaluator (技术评估)
│   └── Pattern Recognition (模式识别)
├── Statistical Engine (统计引擎)
│   ├── VPIP Calculator
│   ├── PFR Calculator
│   └── Win Rate Analyzer
└── Data Pipeline (数据管道)
    ├── Stream Processor (流处理)
    ├── Batch Processor (批处理)
    └── Feature Extractor (特征提取)
```

#### 2.2.2 核心类设计

```python
# 玩家分析器
class PlayerAnalyzer:
    """玩家行为分析器"""

    def __init__(self):
        self.behavior_tracker = BehaviorTracker()
        self.profiler = PlayerProfiler()
        self.stats_engine = StatisticsEngine()

    def analyze_action(
        self,
        player: Player,
        action: Action,
        context: GameContext
    ) -> AnalysisResult:
        """分析单个动作"""
        # 1. 记录行为
        self.behavior_tracker.track(player, action, context)

        # 2. 更新统计数据
        stats = self.stats_engine.update(player, action)

        # 3. 更新玩家画像
        profile = self.profiler.update(player, action, stats)

        return AnalysisResult(stats, profile)

    def classify_player_type(self, player: Player) -> PlayerType:
        """分类玩家类型"""
        vpip = player.stats.vpip
        pfr = player.stats.pfr

        if vpip < 20 and pfr > 15:
            return PlayerType.TAG  # 紧凶
        elif vpip > 30 and pfr > 20:
            return PlayerType.LAG  # 松凶
        elif vpip < 20 and pfr < 10:
            return PlayerType.TIGHT_PASSIVE  # 紧弱
        else:
            return PlayerType.LOOSE_PASSIVE  # 松弱

    def evaluate_skill_level(self, player: Player) -> int:
        """评估技术水平 (0-100分)"""
        score = 0

        # 基础策略理解 (30分)
        if 15 <= player.stats.vpip <= 25:
            score += 15
        if 10 <= player.stats.pfr <= 20:
            score += 15

        # 位置意识 (20分)
        position_awareness = self._check_position_awareness(player)
        score += position_awareness * 20

        # 读牌能力 (25分)
        hand_reading = self._evaluate_hand_reading(player)
        score += hand_reading * 25

        # 资金管理 (25分)
        bankroll_mgmt = self._evaluate_bankroll_management(player)
        score += bankroll_mgmt * 25

        return min(score, 100)


# 行为追踪器
class BehaviorTracker:
    """行为追踪器"""

    def __init__(self):
        self.action_history = deque(maxlen=1000)
        self.pattern_detector = PatternDetector()

    def track(
        self,
        player: Player,
        action: Action,
        context: GameContext
    ):
        """追踪玩家行为"""
        event = BehaviorEvent(
            player_id=player.id,
            action=action,
            context=context,
            timestamp=datetime.now()
        )

        self.action_history.append(event)

        # 检测行为模式
        patterns = self.pattern_detector.detect(event, self.action_history)

        # 存储到数据库
        self._save_to_db(event, patterns)

    def detect_emotion_shift(self, player: Player) -> EmotionState:
        """检测情绪变化"""
        # 基于下注模式的突变检测
        recent_actions = self._get_recent_actions(player, n=20)

        bet_variance = np.var([a.amount for a in recent_actions])
        decision_time_variance = np.var([a.decision_time for a in recent_actions])

        if bet_variance > threshold and decision_time_variance > threshold:
            return EmotionState.TILTED  # 上头状态

        return EmotionState.NORMAL


# 特征提取器
class FeatureExtractor:
    """玩家特征提取器"""

    def extract_features(self, player: Player) -> np.ndarray:
        """提取玩家特征向量"""
        features = []

        # 基础统计特征
        features.extend([
            player.stats.vpip,
            player.stats.pfr,
            player.stats.three_bet_rate,
            player.stats.cbet_rate,
            player.stats.fold_to_cbet,
        ])

        # 位置特征
        features.extend([
            player.stats.vpip_by_position['early'],
            player.stats.vpip_by_position['middle'],
            player.stats.vpip_by_position['late'],
        ])

        # 行为模式特征
        features.extend([
            player.avg_decision_time,
            player.bluff_frequency,
            player.aggression_factor,
        ])

        # 资金管理特征
        features.extend([
            player.avg_buy_in,
            player.stack_volatility,
            player.risk_tolerance,
        ])

        return np.array(features)
```

---

### 2.3 AI训练服务 (ML Training Service)

#### 2.3.1 模块架构
```
ML Training Service
├── Data Pipeline (数据管道)
│   ├── Data Collector (数据采集)
│   ├── Data Cleaner (数据清洗)
│   ├── Feature Engineer (特征工程)
│   └── Data Splitter (数据分割)
├── Model Training (模型训练)
│   ├── Supervised Learning (监督学习)
│   ├── Reinforcement Learning (强化学习)
│   ├── Clustering (聚类)
│   └── Ensemble Methods (集成学习)
├── Model Evaluation (模型评估)
│   ├── Metrics Calculator (指标计算)
│   ├── Cross Validator (交叉验证)
│   └── A/B Tester (A/B测试)
└── Model Deployment (模型部署)
    ├── Model Registry (模型注册)
    ├── Version Manager (版本管理)
    └── Deployment Pipeline (部署流水线)
```

#### 2.3.2 核心类设计

```python
# 玩家行为预测模型
class PlayerBehaviorPredictor:
    """预测玩家下一步动作"""

    def __init__(self, model_path: str):
        self.model = self._load_model(model_path)
        self.feature_extractor = FeatureExtractor()

    def predict_action(
        self,
        player: Player,
        game_state: GameState
    ) -> ActionProbabilities:
        """预测玩家行动概率"""
        # 1. 提取特征
        features = self._extract_features(player, game_state)

        # 2. 模型推理
        probs = self.model.predict_proba(features)

        return ActionProbabilities(
            fold=probs[0],
            call=probs[1],
            raise_=probs[2],
            all_in=probs[3]
        )

    def _extract_features(
        self,
        player: Player,
        game_state: GameState
    ) -> np.ndarray:
        """提取特征向量"""
        features = []

        # 玩家特征
        features.extend(self.feature_extractor.extract_features(player))

        # 游戏状态特征
        features.extend([
            game_state.pot_size,
            game_state.current_bet,
            game_state.player_position,
            game_state.num_active_players,
        ])

        # 牌面特征
        hand_strength = self._calculate_hand_strength(
            player.hole_cards,
            game_state.community_cards
        )
        features.append(hand_strength)

        return np.array(features)


# 发牌策略优化器 (强化学习)
class DealingStrategyOptimizer:
    """使用强化学习优化发牌策略"""

    def __init__(self):
        self.env = PokerEnvironment()
        self.agent = PPOAgent()  # Proximal Policy Optimization
        self.replay_buffer = ReplayBuffer(capacity=100000)

    def train(self, num_episodes: int):
        """训练智能发牌策略"""
        for episode in range(num_episodes):
            state = self.env.reset()
            episode_reward = 0

            while not self.env.is_done():
                # 1. Agent选择发牌策略
                action = self.agent.select_action(state)

                # 2. 执行发牌
                next_state, reward, done = self.env.step(action)

                # 3. 存储经验
                self.replay_buffer.add(state, action, reward, next_state, done)

                # 4. 更新策略
                if len(self.replay_buffer) > batch_size:
                    self.agent.update(self.replay_buffer.sample(batch_size))

                state = next_state
                episode_reward += reward

            print(f"Episode {episode}: Reward = {episode_reward}")

    def _calculate_reward(self, game_result: GameResult) -> float:
        """计算奖励函数"""
        reward = 0

        # 娱乐性指标
        reward += game_result.avg_actions_per_player * 0.3
        reward += game_result.dramatic_moments * 0.2

        # 玩家活跃度
        reward += game_result.player_engagement_score * 0.3

        # 公平性惩罚
        if game_result.fairness_score < 0.9:
            reward -= 10

        return reward


# 玩家聚类模型
class PlayerClusteringModel:
    """自动发现玩家类型"""

    def __init__(self, n_clusters: int = 5):
        self.model = KMeans(n_clusters=n_clusters)
        self.scaler = StandardScaler()

    def fit(self, players: List[Player]):
        """训练聚类模型"""
        # 1. 提取特征
        features = [self._extract_features(p) for p in players]
        X = np.array(features)

        # 2. 标准化
        X_scaled = self.scaler.fit_transform(X)

        # 3. 聚类
        self.model.fit(X_scaled)

        # 4. 解释每个聚类
        self._interpret_clusters(players, self.model.labels_)

    def predict_cluster(self, player: Player) -> int:
        """预测玩家所属聚类"""
        features = self._extract_features(player)
        X = self.scaler.transform([features])
        return self.model.predict(X)[0]

    def _interpret_clusters(self, players: List[Player], labels: np.ndarray):
        """解释聚类含义"""
        for cluster_id in range(self.model.n_clusters):
            cluster_players = [p for p, l in zip(players, labels) if l == cluster_id]

            # 计算聚类中心特征
            avg_vpip = np.mean([p.stats.vpip for p in cluster_players])
            avg_pfr = np.mean([p.stats.pfr for p in cluster_players])
            avg_skill = np.mean([p.skill_score for p in cluster_players])

            print(f"Cluster {cluster_id}:")
            print(f"  VPIP: {avg_vpip:.2f}")
            print(f"  PFR: {avg_pfr:.2f}")
            print(f"  Skill: {avg_skill:.2f}")


# 模型训练管理器
class ModelTrainingManager:
    """管理所有ML模型的训练"""

    def __init__(self):
        self.models = {}
        self.training_jobs = {}
        self.mlflow_client = mlflow.tracking.MlflowClient()

    def train_model(
        self,
        model_name: str,
        config: TrainingConfig
    ) -> str:
        """训练模型并返回job_id"""
        job_id = self._create_job_id()

        # 异步训练
        job = TrainingJob(
            job_id=job_id,
            model_name=model_name,
            config=config
        )

        self.training_jobs[job_id] = job
        job.start()

        return job_id

    def get_best_model(self, model_name: str) -> MLModel:
        """获取最佳模型版本"""
        runs = self.mlflow_client.search_runs(
            experiment_ids=[model_name],
            order_by=["metrics.accuracy DESC"],
            max_results=1
        )

        if runs:
            return mlflow.pyfunc.load_model(f"runs:/{runs[0].info.run_id}/model")

        return None

    def deploy_model(self, model_name: str, version: str):
        """部署模型到生产环境"""
        # 1. 加载模型
        model = self.mlflow_client.get_model_version(model_name, version)

        # 2. 验证模型
        validation_result = self._validate_model(model)
        if not validation_result.passed:
            raise ValueError("Model validation failed")

        # 3. 部署
        self._deploy_to_production(model)

        # 4. 监控
        self._setup_monitoring(model)
```

---

### 2.4 测试服务 (Testing Service)

#### 2.4.1 模块架构
```
Testing Service
├── Simulation Engine (模拟引擎)
│   ├── Virtual Player Manager (虚拟玩家管理)
│   ├── Game Simulator (游戏模拟器)
│   └── Scenario Generator (场景生成器)
├── Fairness Testing (公平性测试)
│   ├── Statistical Validator (统计验证)
│   ├── Chi-Square Test (卡方检验)
│   └── Distribution Analyzer (分布分析)
├── Performance Testing (性能测试)
│   ├── Load Tester (负载测试)
│   ├── Stress Tester (压力测试)
│   └── Benchmark Suite (基准测试)
└── A/B Testing (A/B测试)
    ├── Experiment Manager (实验管理)
    ├── Traffic Splitter (流量分配)
    └── Result Analyzer (结果分析)
```

#### 2.4.2 核心类设计

```python
# 虚拟玩家
class VirtualPlayer:
    """AI虚拟玩家"""

    def __init__(
        self,
        player_type: PlayerType,
        skill_level: int,
        strategy: PlayerStrategy
    ):
        self.type = player_type
        self.skill_level = skill_level
        self.strategy = strategy
        self.stats = PlayerStats()

    def make_decision(
        self,
        game_state: GameState
    ) -> Action:
        """根据策略做决策"""
        return self.strategy.decide(game_state, self)

    def update_after_action(self, result: ActionResult):
        """动作后更新状态"""
        self.stats.update(result)


# 游戏模拟器
class GameSimulator:
    """高速游戏模拟器"""

    def __init__(self, dealing_engine: DealingEngine):
        self.engine = dealing_engine
        self.virtual_players = []

    def simulate_games(
        self,
        num_games: int,
        num_players: int = 6
    ) -> SimulationResult:
        """模拟大量游戏"""
        results = []

        # 创建虚拟玩家
        self.virtual_players = self._create_virtual_players(num_players)

        # 并行模拟
        with multiprocessing.Pool() as pool:
            results = pool.map(
                self._simulate_single_game,
                range(num_games)
            )

        return SimulationResult(results)

    def _simulate_single_game(self, game_id: int) -> GameResult:
        """模拟单局游戏"""
        table = Table(players=self.virtual_players)

        # 发牌
        hand_result = self.engine.deal_hand(table, self.virtual_players)

        # 玩家决策循环
        while not table.is_finished():
            current_player = table.get_current_player()
            action = current_player.make_decision(table.game_state)
            table.apply_action(action)

        return table.get_result()


# 公平性验证器
class FairnessValidator:
    """验证发牌公平性"""

    def validate(
        self,
        game_results: List[GameResult]
    ) -> ValidationReport:
        """综合验证公平性"""
        report = ValidationReport()

        # 1. 卡方检验
        chi_square_result = self._chi_square_test(game_results)
        report.add_test("Chi-Square Test", chi_square_result)

        # 2. 牌面分布检验
        distribution_result = self._test_card_distribution(game_results)
        report.add_test("Card Distribution", distribution_result)

        # 3. 期望值检验
        expected_value_result = self._test_expected_values(game_results)
        report.add_test("Expected Value", expected_value_result)

        # 4. 玩家公平性
        player_fairness_result = self._test_player_fairness(game_results)
        report.add_test("Player Fairness", player_fairness_result)

        return report

    def _chi_square_test(self, results: List[GameResult]) -> TestResult:
        """卡方检验"""
        # 统计每种牌型的出现次数
        observed_freq = self._count_hand_types(results)
        expected_freq = self._calculate_expected_freq(len(results))

        # 计算卡方值
        chi_square_stat = sum(
            (obs - exp) ** 2 / exp
            for obs, exp in zip(observed_freq, expected_freq)
        )

        # 计算p值
        p_value = chi2.sf(chi_square_stat, df=len(observed_freq) - 1)

        return TestResult(
            passed=p_value > 0.05,
            statistic=chi_square_stat,
            p_value=p_value
        )


# A/B测试管理器
class ABTestManager:
    """A/B测试管理"""

    def __init__(self):
        self.experiments = {}

    def create_experiment(
        self,
        name: str,
        variants: List[str],
        traffic_split: List[float]
    ) -> Experiment:
        """创建A/B测试实验"""
        experiment = Experiment(
            name=name,
            variants=variants,
            traffic_split=traffic_split,
            start_time=datetime.now()
        )

        self.experiments[name] = experiment
        return experiment

    def assign_variant(
        self,
        experiment_name: str,
        user_id: str
    ) -> str:
        """为用户分配测试变体"""
        experiment = self.experiments[experiment_name]

        # 一致性哈希确保同一用户总是分配到同一变体
        hash_value = hashlib.md5(f"{user_id}{experiment_name}".encode()).hexdigest()
        hash_int = int(hash_value, 16)

        cumulative = 0
        for variant, split in zip(experiment.variants, experiment.traffic_split):
            cumulative += split
            if hash_int % 100 < cumulative * 100:
                return variant

        return experiment.variants[0]

    def analyze_results(self, experiment_name: str) -> ABTestResult:
        """分析A/B测试结果"""
        experiment = self.experiments[experiment_name]

        # 获取每个变体的数据
        variant_data = {}
        for variant in experiment.variants:
            variant_data[variant] = self._get_variant_metrics(
                experiment_name,
                variant
            )

        # 统计显著性检验
        significance_results = self._test_significance(variant_data)

        return ABTestResult(
            experiment=experiment,
            variant_data=variant_data,
            significance=significance_results,
            recommendation=self._get_recommendation(significance_results)
        )
```

---

## 3. 数据库设计

### 3.1 PostgreSQL 表结构

```sql
-- 玩家表
CREATE TABLE players (
    player_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nickname VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT NOW(),
    level INTEGER DEFAULT 1,
    total_games INTEGER DEFAULT 0,
    total_hands INTEGER DEFAULT 0,
    win_rate DECIMAL(5,2),
    skill_score INTEGER DEFAULT 50,
    player_type VARCHAR(20),
    INDEX idx_player_type (player_type),
    INDEX idx_skill_score (skill_score)
);

-- 牌局表
CREATE TABLE games (
    game_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_id UUID NOT NULL,
    started_at TIMESTAMP DEFAULT NOW(),
    ended_at TIMESTAMP,
    small_blind DECIMAL(10,2),
    big_blind DECIMAL(10,2),
    total_pot DECIMAL(10,2),
    num_players INTEGER,
    algorithm_version VARCHAR(20),
    fairness_score DECIMAL(5,2),
    entertainment_score DECIMAL(5,2),
    INDEX idx_table_id (table_id),
    INDEX idx_started_at (started_at)
);

-- 手牌表
CREATE TABLE hands (
    hand_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    game_id UUID REFERENCES games(game_id),
    player_id UUID REFERENCES players(player_id),
    position INTEGER,
    hole_cards VARCHAR(10),  -- 例如: "AhKd"
    community_cards VARCHAR(20),  -- 例如: "Ac Kc Qh 7d 2s"
    final_hand_type VARCHAR(20),
    profit_loss DECIMAL(10,2),
    actions JSONB,  -- 存储行动序列
    INDEX idx_game_id (game_id),
    INDEX idx_player_id (player_id)
);

-- 行动表
CREATE TABLE actions (
    action_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    hand_id UUID REFERENCES hands(hand_id),
    player_id UUID REFERENCES players(player_id),
    street VARCHAR(10),  -- preflop/flop/turn/river
    action_type VARCHAR(10),  -- fold/call/raise/check/all-in
    amount DECIMAL(10,2),
    pot_size DECIMAL(10,2),
    pot_odds DECIMAL(5,2),
    decision_time_ms INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_hand_id (hand_id),
    INDEX idx_player_id (player_id),
    INDEX idx_action_type (action_type)
);

-- 玩家统计表
CREATE TABLE player_stats (
    stat_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    player_id UUID REFERENCES players(player_id),
    time_period VARCHAR(20),  -- daily/weekly/monthly/all-time
    period_start DATE,
    vpip DECIMAL(5,2),
    pfr DECIMAL(5,2),
    three_bet_rate DECIMAL(5,2),
    cbet_rate DECIMAL(5,2),
    fold_to_cbet DECIMAL(5,2),
    aggression_factor DECIMAL(5,2),
    wtsd DECIMAL(5,2),  -- Went To Showdown
    wmsd DECIMAL(5,2),  -- Won Money at Showdown
    bb_per_100 DECIMAL(10,2),  -- Big Blinds per 100 hands
    UNIQUE(player_id, time_period, period_start),
    INDEX idx_player_period (player_id, time_period)
);

-- AI模型表
CREATE TABLE ml_models (
    model_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    model_name VARCHAR(100) NOT NULL,
    model_type VARCHAR(50),
    version VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    trained_on_dataset UUID,
    training_samples INTEGER,
    accuracy DECIMAL(5,4),
    precision_score DECIMAL(5,4),
    recall DECIMAL(5,4),
    f1_score DECIMAL(5,4),
    model_path VARCHAR(255),
    deployment_status VARCHAR(20),
    UNIQUE(model_name, version)
);

-- A/B测试表
CREATE TABLE ab_tests (
    test_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    test_name VARCHAR(100) NOT NULL,
    description TEXT,
    started_at TIMESTAMP DEFAULT NOW(),
    ended_at TIMESTAMP,
    variants JSONB,  -- 变体配置
    traffic_split JSONB,  -- 流量分配
    status VARCHAR(20),
    winner_variant VARCHAR(50),
    INDEX idx_status (status),
    INDEX idx_started_at (started_at)
);

-- A/B测试结果表
CREATE TABLE ab_test_results (
    result_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    test_id UUID REFERENCES ab_tests(test_id),
    variant VARCHAR(50),
    metric_name VARCHAR(100),
    metric_value DECIMAL(10,4),
    sample_size INTEGER,
    recorded_at TIMESTAMP DEFAULT NOW(),
    INDEX idx_test_variant (test_id, variant)
);
```

### 3.2 MongoDB 集合设计

```javascript
// 完整牌局记录 (用于回放和深度分析)
{
  _id: ObjectId,
  game_id: UUID,
  timestamp: ISODate,
  players: [
    {
      player_id: UUID,
      position: Number,
      initial_stack: Number,
      final_stack: Number
    }
  ],
  streets: {
    preflop: {
      actions: [
        {
          player_id: UUID,
          action: String,
          amount: Number,
          timestamp: ISODate
        }
      ]
    },
    flop: {
      community_cards: [String],
      actions: [...]
    },
    turn: {
      community_card: String,
      actions: [...]
    },
    river: {
      community_card: String,
      actions: [...]
    }
  },
  showdown: {
    players: [
      {
        player_id: UUID,
        hole_cards: [String],
        hand_type: String,
        rank: Number
      }
    ]
  },
  metadata: {
    algorithm_version: String,
    entertainment_factors: Object,
    ai_predictions: Object
  }
}

// 玩家行为序列
{
  _id: ObjectId,
  player_id: UUID,
  session_id: UUID,
  start_time: ISODate,
  end_time: ISODate,
  behavior_sequence: [
    {
      timestamp: ISODate,
      game_state: Object,
      action: String,
      amount: Number,
      emotion_state: String
    }
  ],
  session_summary: {
    total_hands: Number,
    total_profit: Number,
    avg_decision_time: Number,
    tilt_episodes: Number
  }
}

// 训练数据集
{
  _id: ObjectId,
  dataset_id: UUID,
  dataset_name: String,
  version: String,
  created_at: ISODate,
  samples: [
    {
      features: Array,
      label: Any,
      weight: Number
    }
  ],
  statistics: {
    total_samples: Number,
    feature_statistics: Object,
    label_distribution: Object
  }
}
```

### 3.3 Redis 缓存设计

```
# 玩家实时统计 (过期时间: 1小时)
Key: player:stats:{player_id}
Value: {
  "vpip": 23.5,
  "pfr": 18.2,
  "recent_hands": 150,
  "current_streak": "win-3",
  "emotion_state": "normal"
}

# 活跃牌桌 (过期时间: 30分钟)
Key: table:active:{table_id}
Value: {
  "players": [...],
  "current_game_id": "...",
  "pot_size": 150,
  "street": "flop"
}

# AI模型缓存 (过期时间: 24小时)
Key: model:cache:{model_name}:{version}
Value: <序列化的模型对象>

# 实时监控指标 (过期时间: 5分钟)
Key: metrics:realtime
Value: {
  "active_tables": 87,
  "active_players": 523,
  "avg_response_time_ms": 45,
  "qps": 1234
}
```

---

## 4. API设计

### 4.1 RESTful API

```yaml
# 发牌相关API
POST /api/v1/games
  - 创建新游戏

POST /api/v1/games/{game_id}/deal
  - 发牌

GET /api/v1/games/{game_id}
  - 获取游戏信息

POST /api/v1/games/{game_id}/actions
  - 提交玩家动作

# 玩家分析API
GET /api/v1/players/{player_id}/profile
  - 获取玩家画像

GET /api/v1/players/{player_id}/stats
  - 获取玩家统计

GET /api/v1/players/{player_id}/history
  - 获取历史记录

POST /api/v1/players/analyze
  - 批量分析玩家

# AI模型API
GET /api/v1/models
  - 列出所有模型

POST /api/v1/models/train
  - 训练新模型

POST /api/v1/models/{model_id}/predict
  - 模型预测

POST /api/v1/models/{model_id}/deploy
  - 部署模型

# 测试API
POST /api/v1/testing/simulate
  - 运行模拟测试

POST /api/v1/testing/fairness
  - 公平性验证

POST /api/v1/testing/ab-test
  - 创建A/B测试

GET /api/v1/testing/ab-test/{test_id}/results
  - 获取A/B测试结果
```

### 4.2 WebSocket API

```javascript
// 连接WebSocket
ws://api.example.com/ws/game/{game_id}

// 客户端发送消息
{
  "type": "player_action",
  "player_id": "uuid",
  "action": "raise",
  "amount": 100
}

// 服务端推送消息
{
  "type": "dealing_result",
  "game_id": "uuid",
  "cards": ["Ah", "Kd"],
  "community_cards": ["Ac", "Kc", "Qh"],
  "pot": 350
}

{
  "type": "game_update",
  "current_player": "uuid",
  "pot_size": 450,
  "street": "turn"
}
```

---

## 5. 部署架构

### 5.1 Kubernetes部署

```yaml
# 发牌引擎部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dealing-engine
spec:
  replicas: 3
  selector:
    matchLabels:
      app: dealing-engine
  template:
    metadata:
      labels:
        app: dealing-engine
    spec:
      containers:
      - name: dealing-engine
        image: poker-ai/dealing-engine:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url

---
# AI训练服务部署 (使用GPU)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ml-training
spec:
  replicas: 2
  selector:
    matchLabels:
      app: ml-training
  template:
    metadata:
      labels:
        app: ml-training
    spec:
      containers:
      - name: ml-training
        image: poker-ai/ml-training:latest
        resources:
          limits:
            nvidia.com/gpu: 1
        volumeMounts:
        - name: model-storage
          mountPath: /models
      volumes:
      - name: model-storage
        persistentVolumeClaim:
          claimName: model-pvc
```

### 5.2 监控与告警

```yaml
# Prometheus配置
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'dealing-engine'
    kubernetes_sd_configs:
      - role: pod
    relabel_configs:
      - source_labels: [__meta_kubernetes_pod_label_app]
        action: keep
        regex: dealing-engine

# Grafana仪表板
- 系统性能监控
  - QPS / TPS
  - 响应时间 (P50/P95/P99)
  - 错误率

- 业务指标监控
  - 活跃牌桌数
  - 在线玩家数
  - 娱乐性指数
  - 公平性得分

- AI模型监控
  - 模型推理延迟
  - 预测准确率
  - 模型版本分布
```

---

## 6. 安全设计

### 6.1 安全措施

```python
# 1. 数据加密
class DataEncryption:
    """敏感数据加密"""

    @staticmethod
    def encrypt_player_data(data: dict) -> str:
        """加密玩家敏感数据"""
        from cryptography.fernet import Fernet
        key = settings.ENCRYPTION_KEY
        f = Fernet(key)
        return f.encrypt(json.dumps(data).encode())

# 2. 访问控制
class RBACMiddleware:
    """基于角色的访问控制"""

    PERMISSIONS = {
        "admin": ["*"],
        "analyst": ["view_stats", "export_data"],
        "developer": ["view_code", "deploy_test"],
    }

    def check_permission(self, user: User, action: str) -> bool:
        user_permissions = self.PERMISSIONS.get(user.role, [])
        return "*" in user_permissions or action in user_permissions

# 3. 防作弊检测
class CheatDetector:
    """作弊检测"""

    def detect_collusion(self, players: List[Player]) -> bool:
        """检测串通"""
        # 分析玩家之间的异常互动模式
        pass

    def detect_bot(self, player: Player) -> bool:
        """检测机器人"""
        # 基于行为模式识别非人类玩家
        pass
```

---

## 7. 总结

本架构设计涵盖了:
1. **微服务架构**: 模块化、可扩展
2. **AI深度集成**: 机器学习贯穿各个模块
3. **高性能设计**: 支持大规模并发
4. **数据驱动**: 完整的数据采集和分析
5. **安全可靠**: 多层安全机制

下一步建议按照开发路线图逐步实施。
