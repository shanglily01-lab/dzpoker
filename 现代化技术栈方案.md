# 德州扑克AI系统 - 简洁技术栈方案

## 设计原则

- **简洁**: 技术栈精简,易于维护
- **实用**: 选择成熟稳定的技术
- **高效**: 开发效率优先

---

## 推荐技术栈

### 整体架构

```
┌─────────────────────────────────────────┐
│         前端: Vue 3 + Element Plus       │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│         后端: Python (FastAPI)           │
│         - 发牌引擎                       │
│         - 玩家分析                       │
│         - AI推理                         │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│              数据层                      │
│   PostgreSQL + Redis                    │
└─────────────────────────────────────────┘
```

---

## 1. 后端技术栈

### Python 3.11+ (统一后端语言)

**为什么选择Python?**
```
✓ AI/ML生态最强: PyTorch、scikit-learn
✓ 开发效率高: 快速迭代
✓ 团队易招聘: Python开发者多
✓ FastAPI性能够用: 异步+高并发
```

**核心依赖**:
```txt
# requirements.txt

# Web框架
fastapi==0.109.0
uvicorn[standard]==0.27.0
python-multipart==0.0.6

# 数据库
sqlalchemy==2.0.25
asyncpg==0.29.0          # PostgreSQL异步驱动
redis==5.0.1

# 数据处理
pandas==2.1.4
numpy==1.26.3

# AI/ML
torch==2.1.2
scikit-learn==1.4.0

# 工具
pydantic==2.5.3
python-jose==3.3.0       # JWT认证
passlib==1.7.4           # 密码加密

# WebSocket
websockets==12.0
```

### FastAPI 发牌引擎示例

```python
# app/main.py
from fastapi import FastAPI, WebSocket, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import random
import uuid
from datetime import datetime

app = FastAPI(title="德州扑克AI系统", version="1.0.0")

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)


# ==================== 数据模型 ====================

class Card:
    """扑克牌"""
    SUITS = ['♠', '♥', '♦', '♣']
    RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A']

    def __init__(self, suit: int, rank: int):
        self.suit = suit  # 0-3
        self.rank = rank  # 0-12

    def __str__(self):
        return f"{self.RANKS[self.rank]}{self.SUITS[self.suit]}"

    def to_dict(self):
        return {"suit": self.suit, "rank": self.rank, "display": str(self)}


class Deck:
    """牌堆"""

    def __init__(self):
        self.cards: List[Card] = []
        self.reset()

    def reset(self):
        """重置牌堆"""
        self.cards = [
            Card(suit, rank)
            for suit in range(4)
            for rank in range(13)
        ]

    def shuffle(self):
        """洗牌"""
        random.shuffle(self.cards)

    def deal(self, n: int = 1) -> List[Card]:
        """发牌"""
        dealt = self.cards[:n]
        self.cards = self.cards[n:]
        return dealt


# ==================== 请求/响应模型 ====================

class CreateGameRequest(BaseModel):
    num_players: int
    small_blind: float = 1.0
    big_blind: float = 2.0


class GameResponse(BaseModel):
    game_id: str
    num_players: int
    status: str


class DealResponse(BaseModel):
    hole_cards: List[List[dict]]
    deck_remaining: int


class PlayerAction(BaseModel):
    player_id: int
    action: str  # fold, call, raise, check
    amount: Optional[float] = None


# ==================== 游戏状态管理 ====================

class GameManager:
    """游戏管理器"""

    def __init__(self):
        self.games = {}

    def create_game(self, num_players: int, small_blind: float, big_blind: float) -> str:
        """创建新游戏"""
        game_id = str(uuid.uuid4())[:8]

        self.games[game_id] = {
            "id": game_id,
            "num_players": num_players,
            "small_blind": small_blind,
            "big_blind": big_blind,
            "deck": Deck(),
            "hole_cards": [],
            "community_cards": [],
            "pot": 0,
            "status": "waiting",
            "created_at": datetime.now().isoformat()
        }

        return game_id

    def deal_hole_cards(self, game_id: str) -> List[List[Card]]:
        """发底牌"""
        game = self.games.get(game_id)
        if not game:
            raise ValueError("游戏不存在")

        deck = game["deck"]
        deck.reset()
        deck.shuffle()

        # 给每个玩家发2张牌
        hole_cards = []
        for _ in range(game["num_players"]):
            cards = deck.deal(2)
            hole_cards.append(cards)

        game["hole_cards"] = hole_cards
        game["status"] = "preflop"

        return hole_cards

    def deal_flop(self, game_id: str) -> List[Card]:
        """发翻牌"""
        game = self.games.get(game_id)
        deck = game["deck"]

        deck.deal(1)  # 烧牌
        flop = deck.deal(3)
        game["community_cards"].extend(flop)
        game["status"] = "flop"

        return flop

    def deal_turn(self, game_id: str) -> Card:
        """发转牌"""
        game = self.games.get(game_id)
        deck = game["deck"]

        deck.deal(1)  # 烧牌
        turn = deck.deal(1)[0]
        game["community_cards"].append(turn)
        game["status"] = "turn"

        return turn

    def deal_river(self, game_id: str) -> Card:
        """发河牌"""
        game = self.games.get(game_id)
        deck = game["deck"]

        deck.deal(1)  # 烧牌
        river = deck.deal(1)[0]
        game["community_cards"].append(river)
        game["status"] = "river"

        return river


# 全局游戏管理器
game_manager = GameManager()


# ==================== API路由 ====================

@app.get("/")
async def root():
    return {"message": "德州扑克AI系统", "version": "1.0.0"}


@app.post("/api/games", response_model=GameResponse)
async def create_game(request: CreateGameRequest):
    """创建新游戏"""
    if not 2 <= request.num_players <= 10:
        raise HTTPException(status_code=400, detail="玩家数量必须在2-10之间")

    game_id = game_manager.create_game(
        request.num_players,
        request.small_blind,
        request.big_blind
    )

    return GameResponse(
        game_id=game_id,
        num_players=request.num_players,
        status="waiting"
    )


@app.post("/api/games/{game_id}/deal")
async def deal_cards(game_id: str):
    """发牌"""
    try:
        hole_cards = game_manager.deal_hole_cards(game_id)
        return {
            "hole_cards": [[card.to_dict() for card in hand] for hand in hole_cards],
            "deck_remaining": len(game_manager.games[game_id]["deck"].cards)
        }
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))


@app.post("/api/games/{game_id}/flop")
async def deal_flop(game_id: str):
    """发翻牌"""
    flop = game_manager.deal_flop(game_id)
    return {"flop": [card.to_dict() for card in flop]}


@app.post("/api/games/{game_id}/turn")
async def deal_turn(game_id: str):
    """发转牌"""
    turn = game_manager.deal_turn(game_id)
    return {"turn": turn.to_dict()}


@app.post("/api/games/{game_id}/river")
async def deal_river(game_id: str):
    """发河牌"""
    river = game_manager.deal_river(game_id)
    return {"river": river.to_dict()}


@app.get("/api/games/{game_id}")
async def get_game(game_id: str):
    """获取游戏状态"""
    game = game_manager.games.get(game_id)
    if not game:
        raise HTTPException(status_code=404, detail="游戏不存在")

    return {
        "game_id": game["id"],
        "num_players": game["num_players"],
        "status": game["status"],
        "community_cards": [card.to_dict() for card in game["community_cards"]],
        "pot": game["pot"]
    }


# ==================== WebSocket ====================

class ConnectionManager:
    """WebSocket连接管理"""

    def __init__(self):
        self.active_connections: dict[str, List[WebSocket]] = {}

    async def connect(self, game_id: str, websocket: WebSocket):
        await websocket.accept()
        if game_id not in self.active_connections:
            self.active_connections[game_id] = []
        self.active_connections[game_id].append(websocket)

    async def disconnect(self, game_id: str, websocket: WebSocket):
        if game_id in self.active_connections:
            self.active_connections[game_id].remove(websocket)

    async def broadcast(self, game_id: str, message: dict):
        if game_id in self.active_connections:
            for connection in self.active_connections[game_id]:
                await connection.send_json(message)


ws_manager = ConnectionManager()


@app.websocket("/ws/game/{game_id}")
async def game_websocket(websocket: WebSocket, game_id: str):
    """游戏WebSocket连接"""
    await ws_manager.connect(game_id, websocket)
    try:
        while True:
            data = await websocket.receive_json()
            # 处理玩家动作
            action = PlayerAction(**data)
            # 广播给所有玩家
            await ws_manager.broadcast(game_id, {
                "type": "player_action",
                "player_id": action.player_id,
                "action": action.action,
                "amount": action.amount
            })
    except Exception:
        await ws_manager.disconnect(game_id, websocket)


# ==================== 启动 ====================

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

---

## 2. 数据库

### 只用两个数据库

```
PostgreSQL: 持久化数据 (玩家、游戏记录、统计)
Redis: 缓存 + 实时数据 (游戏状态、会话)
```

### PostgreSQL 表结构

```sql
-- 玩家表
CREATE TABLE players (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    nickname VARCHAR(50),
    password_hash VARCHAR(255) NOT NULL,
    chips DECIMAL(12, 2) DEFAULT 1000.00,
    level INT DEFAULT 1,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 游戏记录表
CREATE TABLE games (
    id SERIAL PRIMARY KEY,
    game_uuid VARCHAR(36) UNIQUE NOT NULL,
    num_players INT NOT NULL,
    small_blind DECIMAL(10, 2),
    big_blind DECIMAL(10, 2),
    total_pot DECIMAL(10, 2),
    winner_id INT REFERENCES players(id),
    started_at TIMESTAMP DEFAULT NOW(),
    ended_at TIMESTAMP
);

-- 手牌记录表
CREATE TABLE hands (
    id SERIAL PRIMARY KEY,
    game_id INT REFERENCES games(id),
    player_id INT REFERENCES players(id),
    hole_cards VARCHAR(10),       -- 如: "AhKd"
    final_hand VARCHAR(20),       -- 如: "Full House"
    profit_loss DECIMAL(10, 2),
    created_at TIMESTAMP DEFAULT NOW()
);

-- 玩家统计表
CREATE TABLE player_stats (
    id SERIAL PRIMARY KEY,
    player_id INT REFERENCES players(id) UNIQUE,
    total_games INT DEFAULT 0,
    total_hands INT DEFAULT 0,
    wins INT DEFAULT 0,
    vpip DECIMAL(5, 2) DEFAULT 0,      -- 入池率
    pfr DECIMAL(5, 2) DEFAULT 0,       -- 加注率
    win_rate DECIMAL(5, 2) DEFAULT 0,
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_hands_player ON hands(player_id);
CREATE INDEX idx_hands_game ON hands(game_id);
CREATE INDEX idx_games_started ON games(started_at);
```

### Redis 使用

```python
# app/cache.py
import redis
import json
from typing import Optional

redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)


def cache_game_state(game_id: str, state: dict, expire: int = 3600):
    """缓存游戏状态"""
    redis_client.setex(f"game:{game_id}", expire, json.dumps(state))


def get_game_state(game_id: str) -> Optional[dict]:
    """获取游戏状态"""
    data = redis_client.get(f"game:{game_id}")
    return json.loads(data) if data else None


def cache_player_stats(player_id: int, stats: dict, expire: int = 300):
    """缓存玩家统计"""
    redis_client.setex(f"player_stats:{player_id}", expire, json.dumps(stats))


def get_player_stats(player_id: int) -> Optional[dict]:
    """获取玩家统计"""
    data = redis_client.get(f"player_stats:{player_id}")
    return json.loads(data) if data else None
```

---

## 3. 前端技术栈

### Vue 3 + Element Plus

```
为什么选择Vue 3?
✓ 学习曲线平缓
✓ Element Plus组件库成熟
✓ 适合中后台系统
✓ 国内生态好
```

**核心依赖**:
```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0",
    "element-plus": "^2.5.0",
    "axios": "^1.6.0",
    "echarts": "^5.4.0"
  }
}
```

**项目结构**:
```
frontend/
├── src/
│   ├── views/
│   │   ├── Dashboard.vue      # 控制台
│   │   ├── GameTable.vue      # 牌桌
│   │   └── PlayerStats.vue    # 玩家统计
│   ├── components/
│   │   ├── Card.vue           # 扑克牌组件
│   │   ├── PlayerSeat.vue     # 玩家座位
│   │   └── ChipStack.vue      # 筹码堆
│   ├── stores/
│   │   └── game.js            # 游戏状态管理
│   ├── api/
│   │   └── index.js           # API请求
│   └── App.vue
├── package.json
└── vite.config.js
```

---

## 4. AI模块

### 简化的玩家分析

```python
# app/ai/player_analyzer.py
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from typing import List, Dict
from enum import Enum


class PlayerType(Enum):
    """玩家类型"""
    TAG = "紧凶型"      # Tight Aggressive
    LAG = "松凶型"      # Loose Aggressive
    PASSIVE = "被动型"
    FISH = "鱼"


class PlayerAnalyzer:
    """玩家分析器"""

    def __init__(self):
        self.scaler = StandardScaler()
        self.classifier = RandomForestClassifier(n_estimators=100)

    def calculate_stats(self, actions: List[Dict]) -> Dict:
        """计算玩家统计数据"""
        if not actions:
            return {"vpip": 0, "pfr": 0, "af": 0}

        df = pd.DataFrame(actions)

        # VPIP: 自愿入池率
        preflop = df[df['street'] == 'preflop']
        vpip = 0
        if len(preflop) > 0:
            voluntary = preflop[preflop['action'].isin(['call', 'raise'])]
            vpip = len(voluntary) / len(preflop) * 100

        # PFR: 翻牌前加注率
        pfr = 0
        if len(preflop) > 0:
            raises = preflop[preflop['action'] == 'raise']
            pfr = len(raises) / len(preflop) * 100

        # AF: 激进因子
        aggressive = len(df[df['action'].isin(['raise', 'bet'])])
        passive = len(df[df['action'] == 'call'])
        af = aggressive / passive if passive > 0 else aggressive

        return {
            "vpip": round(vpip, 1),
            "pfr": round(pfr, 1),
            "af": round(af, 2),
            "total_hands": len(df)
        }

    def classify_player(self, stats: Dict) -> PlayerType:
        """分类玩家类型"""
        vpip = stats.get("vpip", 0)
        pfr = stats.get("pfr", 0)

        if vpip < 20:
            if pfr > 12:
                return PlayerType.TAG
            else:
                return PlayerType.PASSIVE
        else:
            if pfr > 15:
                return PlayerType.LAG
            else:
                return PlayerType.FISH

    def evaluate_skill(self, stats: Dict) -> int:
        """评估技术水平 (0-100)"""
        score = 50  # 基础分

        vpip = stats.get("vpip", 0)
        pfr = stats.get("pfr", 0)

        # VPIP评分 (理想范围15-25)
        if 15 <= vpip <= 25:
            score += 15
        elif 10 <= vpip <= 30:
            score += 8

        # PFR评分 (理想范围10-18)
        if 10 <= pfr <= 18:
            score += 15
        elif 5 <= pfr <= 22:
            score += 8

        # PFR/VPIP比例 (理想 > 0.6)
        if vpip > 0:
            ratio = pfr / vpip
            if ratio >= 0.7:
                score += 10
            elif ratio >= 0.5:
                score += 5

        return min(score, 100)
```

---

## 5. 部署

### Docker Compose (推荐)

```yaml
# docker-compose.yml
version: '3.8'

services:
  # 后端API
  api:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/poker
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
    restart: unless-stopped

  # 前端
  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - api
    restart: unless-stopped

  # PostgreSQL
  db:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: poker
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped

  # Redis
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### 后端Dockerfile

```dockerfile
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 前端Dockerfile

```dockerfile
# frontend/Dockerfile
FROM node:20-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
```

---

## 6. 项目结构

```
dzpoker/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py            # FastAPI入口
│   │   ├── models.py          # 数据模型
│   │   ├── database.py        # 数据库连接
│   │   ├── cache.py           # Redis缓存
│   │   ├── routers/
│   │   │   ├── games.py       # 游戏API
│   │   │   ├── players.py     # 玩家API
│   │   │   └── stats.py       # 统计API
│   │   └── ai/
│   │       ├── analyzer.py    # 玩家分析
│   │       └── dealer.py      # 智能发牌
│   ├── tests/
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── src/
│   ├── package.json
│   └── Dockerfile
├── docker-compose.yml
└── README.md
```

---

## 技术栈总结

| 层级 | 技术 | 说明 |
|------|------|------|
| 后端 | Python + FastAPI | 统一语言,开发效率高 |
| 数据库 | PostgreSQL | 主数据存储 |
| 缓存 | Redis | 游戏状态 + 会话 |
| 前端 | Vue 3 + Element Plus | 简单易用 |
| AI | PyTorch + scikit-learn | Python原生支持 |
| 部署 | Docker Compose | 一键部署 |

**优势**:
- 技术栈精简: 只有Python一种后端语言
- 数据库简化: 只有PostgreSQL + Redis
- 部署简单: Docker Compose一键启动
- 团队友好: 技术栈常见,招人容易
